package tests

import (
	"encoding/hex"
	"fmt"
	"strings"
	"testing"
	"time"

	"github.com/slicingmelon/gobypass403/core/engine/payload"
	"github.com/slicingmelon/gobypass403/core/engine/rawhttp"
)

func TestPathPrefixPayloads(t *testing.T) {
	targetURL := "http://localhost/admin/config" // Target URL with multiple segments
	moduleName := "path_prefix"

	// 1. Generate Payloads
	pg := payload.NewPayloadGenerator(payload.PayloadGeneratorOptions{
		TargetURL:    targetURL,
		BypassModule: moduleName,
	})
	generatedPayloads := pg.GeneratePathPrefixPayloads(targetURL, moduleName)
	if len(generatedPayloads) == 0 {
		t.Fatal("No payloads were generated")
	}
	numPayloads := len(generatedPayloads)
	t.Logf("Generated %d payloads for %s.", numPayloads, moduleName)

	// 2. Create channel for server results (use a dynamic size or large enough buffer)
	receivedURIsChan := make(chan string, numPayloads+100) // Buffer should be adequate

	// 3. Start the server
	serverAddr, stopServer := startRawTestServer(t, receivedURIsChan)
	defer stopServer()

	// 4. Update payload destinations
	for i := range generatedPayloads {
		generatedPayloads[i].Scheme = "http"
		generatedPayloads[i].Host = serverAddr
	}

	// Prepare expected URIs map (hex-encoded)
	expectedURIsHex := make(map[string]struct{})
	for _, p := range generatedPayloads {
		hexURI := hex.EncodeToString([]byte(p.RawURI))
		expectedURIsHex[hexURI] = struct{}{}
	}
	// Log if the number of unique hex URIs is different from total generated, indicating duplicates
	if len(expectedURIsHex) != numPayloads {
		t.Logf("Warning: Number of unique expected URIs (%d) differs from total generated payloads (%d). This might indicate duplicate RawURIs were generated by the module.", len(expectedURIsHex), numPayloads)
	}

	// 5. Send Requests
	clientOpts := rawhttp.DefaultHTTPClientOptions()
	clientOpts.Timeout = 5 * time.Second // Increased timeout for potentially many requests
	clientOpts.MaxRetries = 0
	clientOpts.MaxConsecutiveFailedReqs = numPayloads + 100 // Allow for some failures without stopping everything

	wp := rawhttp.NewRequestWorkerPool(clientOpts, 20) // Increased workers for potentially large payload set
	resultsChan := wp.ProcessRequests(generatedPayloads)

	// 6. Drain client results
	responseCount := 0
	for range resultsChan {
		responseCount++
	}
	wp.Close()
	t.Logf("Client processed %d responses.", responseCount)

	// 7. Close Server's Results Channel
	// Give a brief moment for any in-flight server handlers to send their URI
	time.Sleep(200 * time.Millisecond)
	close(receivedURIsChan)

	// 8. Verify Received URIs & Check for literal spaces
	receivedRawURIs := []string{}
	literalSpaceFound := false
	for uri := range receivedURIsChan { // Drain the channel completely
		receivedRawURIs = append(receivedRawURIs, uri)
		if strings.Contains(uri, " ") {
			t.Errorf("Literal space '\x20' found in received URI path: '%s' (Hex: %s)", uri, hex.EncodeToString([]byte(uri)))
			literalSpaceFound = true
		}
	}

	if literalSpaceFound {
		// If spaces were found, it's a critical error for this test's objective.
		// The specific URIs with spaces are already logged by t.Errorf.
		// We might still want to proceed to full comparison to see other differences,
		// or t.FailNow() here if space presence is an absolute blocker.
		// For now, we'll let it proceed to full comparison.
		t.Log("Test failed due to literal spaces found in received URI paths.")
	}

	receivedURIsHex := make(map[string]struct{})
	for _, rawURI := range receivedRawURIs {
		hexURI := hex.EncodeToString([]byte(rawURI))
		receivedURIsHex[hexURI] = struct{}{}
	}

	// 9. Comparison
	expectedCount := len(expectedURIsHex)
	receivedCount := len(receivedURIsHex)

	if expectedCount != receivedCount {
		t.Errorf("Mismatch in unique URI count: Expected %d, Server received %d", expectedCount, receivedCount)

		missing := []string{}
		for hexExp := range expectedURIsHex {
			if _, found := receivedURIsHex[hexExp]; !found {
				rawBytes, _ := hex.DecodeString(hexExp)
				missing = append(missing, fmt.Sprintf("'%s' (Hex: %s)", string(rawBytes), hexExp))
			}
		}
		extra := []string{}
		for hexRcv := range receivedURIsHex {
			if _, found := expectedURIsHex[hexRcv]; !found {
				rawBytes, _ := hex.DecodeString(hexRcv)
				extra = append(extra, fmt.Sprintf("'%s' (Hex: %s)", string(rawBytes), hexRcv))
			}
		}
		if len(missing) > 0 {
			// Using t.Errorf instead of t.Fatalf to see all issues if spaces were also found.
			t.Errorf("URIs expected but not received by server (%d missing):\n%s", len(missing), strings.Join(missing, "\n"))
		}
		if len(extra) > 0 {
			t.Errorf("URIs received by server but not expected (%d extra):\n%s", len(extra), strings.Join(extra, "\n"))
		}
	} else {
		// If counts match, ensure all expected URIs were indeed received
		match := true
		for hexExp := range expectedURIsHex {
			if _, found := receivedURIsHex[hexExp]; !found {
				rawBytes, _ := hex.DecodeString(hexExp)
				t.Errorf("CRITICAL: Counts matched but expected URI not found in received set: '%s' (Hex: %s)", string(rawBytes), hexExp)
				match = false // Should not happen if counts match and set logic is correct
			}
		}
		if match {
			t.Logf("Successfully verified %d unique received URIs against %d expected unique URIs. No discrepancies in sets.", receivedCount, expectedCount)
		}
	}

	// Final check on the literal space flag
	if literalSpaceFound {
		t.Error("Test concluded with errors: Literal spaces were found in URI paths.")
	} else if expectedCount == receivedCount && responseCount == numPayloads { // Ensure all requests were responded to
		t.Log("Test passed: All URI paths correctly received without literal spaces, counts match, and all requests processed.")
	} else if expectedCount == receivedCount { // Counts match but not all responses processed (likely proxy issue)
		t.Logf("Test partially passed: URI sets match (%d) and no literal spaces, but only %d responses processed out of %d. Check proxy connectivity.", expectedCount, responseCount, numPayloads)
	} else {
		t.Log("Test failed due to URI mismatches or other errors reported above.")
	}
}

func TestPathPrefixPayloadsWithBurpProxy(t *testing.T) {
	//targetURL := "http://localhost/admin/config" // Target URL with multiple segments
	targetURL := "http://localhost/admin" // Target URL with multiple segments
	moduleName := "path_prefix"
	proxyURL := "http://127.0.0.1:8080"

	t.Logf("--- Starting TestPathPrefixPayloadsWithBurpProxy (%s) --- Proxy: %s ---", moduleName, proxyURL)

	// 1. Generate Payloads
	pg := payload.NewPayloadGenerator(payload.PayloadGeneratorOptions{
		TargetURL:    targetURL,
		BypassModule: moduleName,
	})
	generatedPayloads := pg.GeneratePathPrefixPayloads(targetURL, moduleName)
	if len(generatedPayloads) == 0 {
		t.Fatal("(WithProxy) No payloads were generated")
	}
	numPayloads := len(generatedPayloads)
	t.Logf("(WithProxy) Generated %d payloads for %s.", numPayloads, moduleName)

	// 2. Create channel for server results
	receivedURIsChan := make(chan string, numPayloads+100)

	// 3. Start the server
	serverAddr, stopServer := startRawTestServer(t, receivedURIsChan)
	defer stopServer()

	// 4. Update payload destinations
	for i := range generatedPayloads {
		generatedPayloads[i].Scheme = "http"
		generatedPayloads[i].Host = serverAddr // The client will send this to the proxy, proxy forwards to this.
	}

	// Prepare expected URIs map (hex-encoded)
	expectedURIsHex := make(map[string]struct{})
	for _, p := range generatedPayloads {
		hexURI := hex.EncodeToString([]byte(p.RawURI))
		expectedURIsHex[hexURI] = struct{}{}
	}
	if len(expectedURIsHex) != numPayloads {
		t.Logf("(WithProxy) Warning: Number of unique expected URIs (%d) differs from total generated payloads (%d).", len(expectedURIsHex), numPayloads)
	}

	// 5. Send Requests with Proxy
	clientOpts := rawhttp.DefaultHTTPClientOptions()
	clientOpts.Timeout = 20 * time.Second // Increased timeout when proxy is involved
	clientOpts.MaxRetries = 0
	clientOpts.MaxConsecutiveFailedReqs = numPayloads + 100
	clientOpts.ProxyURL = proxyURL                 // Key change: Set the proxy
	clientOpts.RequestDelay = 5 * time.Millisecond // Added delay between requests

	t.Logf("(WithProxy) Client configured to use proxy: %s, Timeout: %s, RequestDelay: %s", clientOpts.ProxyURL, clientOpts.Timeout, clientOpts.RequestDelay)

	wp := rawhttp.NewRequestWorkerPool(clientOpts, 50) // Reduced workers ...
	resultsChan := wp.ProcessRequests(generatedPayloads)

	// 6. Drain client results
	responseCount := 0      // This counts actual responses received via the proxy
	for range resultsChan { // We don't need to inspect 'result' here for errors, as RawHTTPResponseDetails has no error field.
		responseCount++ // Client-side transport/proxy errors will result in fewer responses than payloads.
	}
	wp.Close()
	t.Logf("(WithProxy) Client processed %d responses through proxy.", responseCount)

	// 7. Close Server's Results Channel
	time.Sleep(500 * time.Millisecond) // Slightly longer wait with proxy
	close(receivedURIsChan)

	// 8. Verify Received URIs & Check for literal spaces
	receivedRawURIs := []string{}
	literalSpaceFoundInProxyTest := false
	for uri := range receivedURIsChan {
		receivedRawURIs = append(receivedRawURIs, uri)
		if strings.Contains(uri, " ") {
			t.Errorf("(WithProxy) Literal space '\x20' found in received URI path: '%s' (Hex: %s)", uri, hex.EncodeToString([]byte(uri)))
			literalSpaceFoundInProxyTest = true
		}
	}

	if literalSpaceFoundInProxyTest {
		t.Log("(WithProxy) Test potentially failed due to literal spaces found in received URI paths via proxy.")
	}

	receivedURIsHex := make(map[string]struct{})
	for _, rawURI := range receivedRawURIs {
		hexURI := hex.EncodeToString([]byte(rawURI))
		receivedURIsHex[hexURI] = struct{}{}
	}

	// 9. Comparison
	expectedCount := len(expectedURIsHex)
	receivedCountViaProxy := len(receivedURIsHex)

	t.Logf("(WithProxy) Expected %d unique URIs. Received %d unique URIs via proxy.", expectedCount, receivedCountViaProxy)

	if expectedCount != receivedCountViaProxy {
		t.Errorf("(WithProxy) Mismatch in unique URI count: Expected %d, Server received %d via proxy", expectedCount, receivedCountViaProxy)
		// Detailed missing/extra logic (same as before, with (WithProxy) prefix)
		missing := []string{}
		for hexExp := range expectedURIsHex {
			if _, found := receivedURIsHex[hexExp]; !found {
				rawBytes, _ := hex.DecodeString(hexExp)
				missing = append(missing, fmt.Sprintf("'%s' (Hex: %s)", string(rawBytes), hexExp))
			}
		}
		extra := []string{}
		for hexRcv := range receivedURIsHex {
			if _, found := expectedURIsHex[hexRcv]; !found {
				rawBytes, _ := hex.DecodeString(hexRcv)
				extra = append(extra, fmt.Sprintf("'%s' (Hex: %s)", string(rawBytes), hexRcv))
			}
		}
		if len(missing) > 0 {
			t.Errorf("(WithProxy) URIs expected but not received by server (%d missing):\n%s", len(missing), strings.Join(missing, "\n"))
		}
		if len(extra) > 0 {
			t.Errorf("(WithProxy) URIs received by server but not expected (%d extra):\n%s", len(extra), strings.Join(extra, "\n"))
		}
	}

	// Final check
	if literalSpaceFoundInProxyTest {
		t.Error("(WithProxy) Test concluded with errors: Literal spaces WERE FOUND in URI paths when using proxy.")
	}
	if responseCount < numPayloads {
		t.Logf("(WithProxy) Warning: Not all requests were processed by the client (%d/%d). This likely indicates issues connecting to or communicating with the proxy at %s.", responseCount, numPayloads, proxyURL)
	}
	if receivedCountViaProxy < expectedCount {
		t.Logf("(WithProxy) Warning: Not all expected URIs were received by the test server (%d/%d). Ensure proxy is running and forwarding correctly.", receivedCountViaProxy, expectedCount)
	}

	if !literalSpaceFoundInProxyTest && expectedCount == receivedCountViaProxy && responseCount == numPayloads {
		t.Log("(WithProxy) Test passed: All URI paths correctly received via proxy without literal spaces, counts match, and all requests processed.")
	} else {
		t.Log("(WithProxy) Test finished. Review logs for failures or warnings related to spaces, URI mismatches, or proxy connectivity.")
		if !literalSpaceFoundInProxyTest && expectedCount == receivedCountViaProxy {
			// If spaces are not an issue and URIs match, but responseCount is low, it's a proxy comms issue mostly.
			t.Log("(WithProxy) Note: No literal spaces detected and URI sets matched, but request processing count was low. Primarily a proxy communication/forwarding test concern.")
		}
		// The test will be marked as failed by t.Error or t.Errorf if critical issues were found.
	}
}
